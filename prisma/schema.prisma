generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// NextAuth.js Required Models
// ============================================================================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]

  // User-scoped data relations
  indicators              Indicator[]             @relation("IndicatorOwner")
  indicatorValueCaches    IndicatorValueCache[]
  strategies              Strategy[]
  backtestHistory         BacktestHistoryEntry[]
  groups                  StockGroup[]
  viewSettings            ViewSetting[]
  settings                UserSettings?
  userStocks              UserStock[]             // User's dataset collection

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserSettings {
  id            String  @id @default(cuid())
  userId        String  @unique
  setupComplete Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================================================
// PUBLIC STOCK DATA (Shared Across All Users)
// ============================================================================

/// Stock master data - information about each stock
model Stock {
  id         String  @id @default(cuid())
  symbol     String  // e.g., "000001"
  name       String  // e.g., "平安银行"
  dataSource String  // e.g., "stock_zh_a_hist"
  category   String? // e.g., "A股", "港股", "指数"
  exchange   String? // e.g., "sh", "sz"

  // Metadata
  firstDate  DateTime?
  lastDate   DateTime?
  lastUpdate DateTime?
  rowCount   Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  priceData  StockPrice[]
  userStocks UserStock[]   // Users who have this stock in their collection

  @@unique([symbol, dataSource])
  @@index([symbol])
  @@index([dataSource])
  @@index([category])
  @@index([lastDate])
}

/// Stock OHLCV price data - time-series data
model StockPrice {
  id      String   @id @default(cuid())
  stockId String
  date    DateTime @db.Date

  // OHLCV data
  open   Decimal @db.Decimal(18, 4)
  high   Decimal @db.Decimal(18, 4)
  low    Decimal @db.Decimal(18, 4)
  close  Decimal @db.Decimal(18, 4)
  volume BigInt  @default(0)

  // Extended data from AKShare
  turnover     Decimal? @db.Decimal(24, 2) // 成交额 (可能很大)
  amplitude    Decimal? @db.Decimal(12, 4) // 振幅 (%)
  changePct    Decimal? @db.Decimal(12, 4) // 涨跌幅 (%)
  changeAmount Decimal? @db.Decimal(18, 4) // 涨跌额
  turnoverRate Decimal? @db.Decimal(12, 4) // 换手率 (%)

  stock Stock @relation(fields: [stockId], references: [id], onDelete: Cascade)

  @@unique([stockId, date])
  @@index([stockId, date])
  @@index([date])
}

/// User's dataset collection - tracks which stocks a user has added
/// Stock data is shared, but each user has their own collection
model UserStock {
  id      String   @id @default(cuid())
  userId  String
  stockId String
  addedAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  stock Stock @relation(fields: [stockId], references: [id], onDelete: Cascade)

  @@unique([userId, stockId])
  @@index([userId])
  @@index([stockId])
}

// ============================================================================
// INDICATOR SYSTEM (Flexible Visibility)
// ============================================================================

/// Indicator definitions with flexible visibility
/// visibleTo: [] = public (everyone), ['userId1', 'userId2'] = only these users
model Indicator {
  id String @id @default(cuid())

  // Ownership & Visibility
  ownerId   String
  visibleTo String[] // Empty = public, has values = only specified users can access

  // Basic Info
  name         String
  description  String @db.Text
  pythonCode   String @db.Text
  outputColumn String

  // Dependencies
  dependencies      String[] // Array of indicator IDs
  dependencyColumns String[] // Specific columns like "MACD:DIF", "SMA_20"

  // Group indicator fields
  isGroup         Boolean  @default(false)
  groupName       String?
  expectedOutputs String[] // e.g., ["DIF", "DEA", "MACD"]

  // External datasets (stored as JSON)
  externalDatasets Json? // Record<string, { stockId: string }>

  // Metadata (for browsing/discovery when public)
  category String?  // e.g., "Trend", "Momentum", "Volume"
  tags     String[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  owner             User                  @relation("IndicatorOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  precomputedValues IndicatorValue[]
  userCaches        IndicatorValueCache[]

  @@unique([ownerId, name])
  @@index([ownerId])
  @@index([visibleTo])
  @@index([category])
}

/// Pre-computed indicator values for public indicators (shared cache)
model IndicatorValue {
  id          String   @id @default(cuid())
  indicatorId String
  stockId     String
  date        DateTime @db.Date

  // For single indicators
  value Decimal? @db.Decimal(18, 6)

  // For group indicators (JSONB for multiple outputs)
  groupValues Json? // { "DIF": 1.23, "DEA": 2.34, "MACD": -1.11 }

  computedAt DateTime @default(now())

  indicator Indicator @relation(fields: [indicatorId], references: [id], onDelete: Cascade)

  @@unique([indicatorId, stockId, date])
  @@index([indicatorId, stockId, date])
  @@index([stockId, date])
}

/// User-specific indicator value cache (for private indicators)
model IndicatorValueCache {
  id          String   @id @default(cuid())
  userId      String
  indicatorId String
  stockId     String
  date        DateTime @db.Date

  value       Decimal? @db.Decimal(18, 6)
  groupValues Json?

  computedAt DateTime @default(now())

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  indicator Indicator @relation(fields: [indicatorId], references: [id], onDelete: Cascade)

  @@unique([userId, indicatorId, stockId, date])
  @@index([userId, stockId, date])
  @@index([indicatorId, stockId])
}

// ============================================================================
// USER-SPECIFIC DATA (Private)
// ============================================================================

/// Trading strategies (always private)
model Strategy {
  id               String   @id @default(cuid())
  userId           String
  name             String
  description      String   @db.Text
  pythonCode       String   @db.Text
  strategyType     String   @default("single") // 'single' | 'portfolio'
  constraints      Json? // PortfolioConstraints
  parameters       Json? // Record<string, any>
  externalDatasets Json? // Record<string, { stockId: string }>
  dependencies     String[] // Indicator names this strategy depends on

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user            User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  backtestHistory BacktestHistoryEntry[]

  @@unique([userId, name])
  @@index([userId])
}

/// Backtest history entries
model BacktestHistoryEntry {
  id           String @id @default(cuid())
  userId       String
  strategyId   String
  strategyName String
  strategyType String // 'single' | 'portfolio'

  // Target information
  target Json // { type, stockId?, stockIds?, groupId?, groupName? }

  // Parameters
  parameters Json // { initialCash, commission, startDate?, endDate?, etc. }

  // Full backtest result
  result Json

  // Metadata
  starred Boolean  @default(false)
  notes   String?  @db.Text
  tags    String[]

  // Denormalized summary for filtering/sorting
  totalReturn    Float
  totalReturnPct Float
  sharpeRatio    Float
  tradeCount     Int
  duration       Int

  createdAt DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  strategy Strategy @relation(fields: [strategyId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([userId, createdAt])
  @@index([userId, starred])
  @@index([strategyId])
}

/// User-defined stock groups (watchlists, portfolios)
model StockGroup {
  id             String   @id @default(cuid())
  userId         String
  name           String
  description    String?  @db.Text
  stockIds       String[] // Array of Stock IDs
  isDataSource   Boolean  @default(false)
  dataSourceName String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name])
  @@index([userId])
}

/// View settings for chart configurations
model ViewSetting {
  id                 String   @id @default(cuid())
  userId             String
  name               String
  enabledIndicators1 String[]
  enabledIndicators2 String[]
  constantLines1     Json // ConstantLine[]
  constantLines2     Json // ConstantLine[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name])
  @@index([userId])
}

// ============================================================================
// DATA IMPORT JOB TRACKING
// ============================================================================

enum ImportJobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

/// Track data import jobs for background processing
model DataImportJob {
  id         String          @id @default(cuid())
  symbol     String
  dataSource String
  status     ImportJobStatus @default(PENDING)

  // Progress tracking
  progress Int     @default(0) // 0-100
  message  String?

  // Error handling
  errorMessage String?
  retryCount   Int     @default(0)

  // Timestamps
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([status])
  @@index([symbol, dataSource])
}
