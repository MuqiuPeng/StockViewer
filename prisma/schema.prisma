generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// NextAuth.js Required Models
// ============================================================================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]

  // User's collections (what they're using)
  userStocks       UserStock[]
  userIndicators   UserIndicator[]
  userStrategies   UserStrategy[]
  userGroups       UserStockGroup[]
  userViewSettings UserViewSetting[]

  // User created content
  createdIndicators Indicator[] @relation("IndicatorCreator")
  createdStrategies Strategy[]  @relation("StrategyCreator")
  createdGroups     StockGroup[] @relation("GroupCreator")
  createdViewSettings ViewSetting[] @relation("ViewSettingCreator")

  // Other user data
  indicatorValueCaches IndicatorValueCache[]
  backtestHistory      BacktestHistoryEntry[]
  settings             UserSettings?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserSettings {
  id            String  @id @default(cuid())
  userId        String  @unique
  setupComplete Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================================================
// SHARED STOCK DATA
// ============================================================================

/// Stock master data - shared across all users
model Stock {
  id         String  @id @default(cuid())
  symbol     String
  name       String
  dataSource String
  category   String?
  exchange   String?

  firstDate  DateTime?
  lastDate   DateTime?
  lastUpdate DateTime?
  rowCount   Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  priceData  StockPrice[]
  userStocks UserStock[]

  @@unique([symbol, dataSource])
  @@index([symbol])
  @@index([dataSource])
  @@index([category])
}

/// Stock price time-series data
model StockPrice {
  id      String   @id @default(cuid())
  stockId String
  date    DateTime @db.Date

  open   Decimal @db.Decimal(18, 4)
  high   Decimal @db.Decimal(18, 4)
  low    Decimal @db.Decimal(18, 4)
  close  Decimal @db.Decimal(18, 4)
  volume BigInt  @default(0)

  turnover     Decimal? @db.Decimal(24, 2)
  amplitude    Decimal? @db.Decimal(12, 4)
  changePct    Decimal? @db.Decimal(12, 4)
  changeAmount Decimal? @db.Decimal(18, 4)
  turnoverRate Decimal? @db.Decimal(12, 4)

  stock Stock @relation(fields: [stockId], references: [id], onDelete: Cascade)

  @@unique([stockId, date])
  @@index([stockId, date])
  @@index([date])
}

/// User's stock collection
model UserStock {
  id      String   @id @default(cuid())
  userId  String
  stockId String
  addedAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  stock Stock @relation(fields: [stockId], references: [id], onDelete: Cascade)

  @@unique([userId, stockId])
  @@index([userId])
  @@index([stockId])
}

// ============================================================================
// SHARED INDICATORS
// ============================================================================

/// Indicator definitions - can be shared
/// visibleTo: [] = public, ['userId1'] = only those users
model Indicator {
  id        String   @id @default(cuid())
  createdBy String
  visibleTo String[]

  name         String
  description  String @db.Text
  pythonCode   String @db.Text
  outputColumn String

  dependencies      String[]
  dependencyColumns String[]

  isGroup         Boolean  @default(false)
  groupName       String?
  expectedOutputs String[]

  externalDatasets Json?
  category         String?
  tags             String[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  creator           User                  @relation("IndicatorCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  userIndicators    UserIndicator[]
  precomputedValues IndicatorValue[]
  userCaches        IndicatorValueCache[]

  @@unique([name]) // Globally unique names for shared indicators
  @@index([createdBy])
  @@index([visibleTo])
  @@index([category])
}

/// User's indicator collection (subscriptions)
model UserIndicator {
  id          String   @id @default(cuid())
  userId      String
  indicatorId String
  addedAt     DateTime @default(now())

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  indicator Indicator @relation(fields: [indicatorId], references: [id], onDelete: Cascade)

  @@unique([userId, indicatorId])
  @@index([userId])
  @@index([indicatorId])
}

/// Pre-computed indicator values (shared cache for public indicators)
model IndicatorValue {
  id          String   @id @default(cuid())
  indicatorId String
  stockId     String
  date        DateTime @db.Date

  value       Decimal? @db.Decimal(18, 6)
  groupValues Json?

  computedAt DateTime @default(now())

  indicator Indicator @relation(fields: [indicatorId], references: [id], onDelete: Cascade)

  @@unique([indicatorId, stockId, date])
  @@index([indicatorId, stockId, date])
  @@index([stockId, date])
}

/// User-specific indicator value cache
model IndicatorValueCache {
  id          String   @id @default(cuid())
  userId      String
  indicatorId String
  stockId     String
  date        DateTime @db.Date

  value       Decimal? @db.Decimal(18, 6)
  groupValues Json?

  computedAt DateTime @default(now())

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  indicator Indicator @relation(fields: [indicatorId], references: [id], onDelete: Cascade)

  @@unique([userId, indicatorId, stockId, date])
  @@index([userId, stockId, date])
  @@index([indicatorId, stockId])
}

// ============================================================================
// SHARED STRATEGIES
// ============================================================================

/// Trading strategies - can be shared
/// visibleTo: [] = public, ['userId1'] = only those users
model Strategy {
  id        String   @id @default(cuid())
  createdBy String
  visibleTo String[]

  name             String
  description      String   @db.Text
  pythonCode       String   @db.Text
  strategyType     String   @default("single")
  constraints      Json?
  parameters       Json?
  externalDatasets Json?
  dependencies     String[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  creator         User                   @relation("StrategyCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  userStrategies  UserStrategy[]
  backtestHistory BacktestHistoryEntry[]

  @@unique([name]) // Globally unique names for shared strategies
  @@index([createdBy])
  @@index([visibleTo])
}

/// User's strategy collection (subscriptions)
model UserStrategy {
  id         String   @id @default(cuid())
  userId     String
  strategyId String
  addedAt    DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  strategy Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  @@unique([userId, strategyId])
  @@index([userId])
  @@index([strategyId])
}

/// Backtest history - always user-specific
model BacktestHistoryEntry {
  id           String @id @default(cuid())
  userId       String
  strategyId   String
  strategyName String
  strategyType String

  target     Json
  parameters Json
  result     Json

  starred Boolean  @default(false)
  notes   String?  @db.Text
  tags    String[]

  totalReturn    Float
  totalReturnPct Float
  sharpeRatio    Float
  tradeCount     Int
  duration       Int

  createdAt DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  strategy Strategy @relation(fields: [strategyId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([userId, createdAt])
  @@index([userId, starred])
  @@index([strategyId])
}

// ============================================================================
// SHARED STOCK GROUPS
// ============================================================================

/// Stock groups (watchlists, portfolios) - can be shared
/// visibleTo: [] = public, ['userId1'] = only those users
model StockGroup {
  id        String   @id @default(cuid())
  createdBy String
  visibleTo String[]

  name           String
  description    String?  @db.Text
  stockIds       String[]
  isDataSource   Boolean  @default(false)
  dataSourceName String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  creator    User             @relation("GroupCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  userGroups UserStockGroup[]

  @@unique([name]) // Globally unique names for shared groups
  @@index([createdBy])
  @@index([visibleTo])
}

/// User's group collection (subscriptions)
model UserStockGroup {
  id      String   @id @default(cuid())
  userId  String
  groupId String
  addedAt DateTime @default(now())

  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  group StockGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
  @@index([userId])
  @@index([groupId])
}

// ============================================================================
// SHARED VIEW SETTINGS
// ============================================================================

/// View settings (chart configs) - can be shared as presets
/// visibleTo: [] = public, ['userId1'] = only those users
model ViewSetting {
  id        String   @id @default(cuid())
  createdBy String
  visibleTo String[]

  name               String
  enabledIndicators1 String[]
  enabledIndicators2 String[]
  constantLines1     Json
  constantLines2     Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  creator          User              @relation("ViewSettingCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  userViewSettings UserViewSetting[]

  @@unique([name]) // Globally unique names for shared presets
  @@index([createdBy])
  @@index([visibleTo])
}

/// User's view setting collection (subscriptions)
model UserViewSetting {
  id            String   @id @default(cuid())
  userId        String
  viewSettingId String
  addedAt       DateTime @default(now())

  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  viewSetting ViewSetting @relation(fields: [viewSettingId], references: [id], onDelete: Cascade)

  @@unique([userId, viewSettingId])
  @@index([userId])
  @@index([viewSettingId])
}

// ============================================================================
// DATA IMPORT JOB TRACKING
// ============================================================================

enum ImportJobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model DataImportJob {
  id         String          @id @default(cuid())
  symbol     String
  dataSource String
  status     ImportJobStatus @default(PENDING)

  progress Int     @default(0)
  message  String?

  errorMessage String?
  retryCount   Int     @default(0)

  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([status])
  @@index([symbol, dataSource])
}
